"""
Control tools
-------------
control_tool.py

Tools to help generate ATM control files
"""
from string import Template
from datetime import datetime

example = {
    "first": "named",
    "last": "person",
    "date": datetime.now(),
    "input-dir": "./input",
    "output-dir": "./output",
    "control-dir": "./control",
    "seprate_archive_data": True,
    "seprate_init_area_data": True,
    "cohorts": ["cohort1", "cohort2", "cohort3"],
    "init-dist-fig": True,
    "norm-dist-fig": True,
    "init-age-fig": True,
    'ice-distribution': "wedge",
    'drainage-efficiency': "random",
    'FDD-in': "fdd-data.yaml",
    'TDD-in': "tdd-data.yaml",
    'lakes-drain-to': "cohort 1",
    'ponds-fill-to': "cohort 1",
    'lake_types': ['cohort4', 'cohort5'],
    'pond_types': ['cohort6'],
    'cohort-transitions': {
        "cohort1": {'transition_type':'POI', 'transition_to': 'cohort2'},
        "cohort2": {
            'transition_type':'lake_to_pond', 'transition_to': 'cohort3'
        },
        "cohort3": {
            'transition_type':'pond_to_lake', 'transition_to': 'cohort1'
        },
    }
}

def add_break_line(settings = {'symbol':'=', 'len':64}):
    """create a line used in comments

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    return '#' + settings['symbol'] * settings['len'] + '\n'

def add_main_header(settings):
    """add the main file header

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    s = Template(
"""#================================================================
#       ALASKA THERMOKARST MODEL CONTROL FILE
# Generated on: $date
# Generated by: $first $last
#================================================================

"""
    )
    return s.substitute(
        date=settings['date'], 
        first=settings['first'],
        last=settings['last']
    )

def add_yaml_notes(settings):
    """add notes on yaml format

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    s = Template(
"""#================================================================
# Some Notes on yaml formating:
#   yes and no are treated as true and false. If you want the 
#   string yes or the string no put it in quotes (i.e "yes")
#================================================================

"""
    )
    return s.substitute()

def add_directory_info(settings):
    """add directory related config keys

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    s = Template(
"""#================================================================
# INFORMATION NEEDED TO SET UP THE SIMULATION DIRECTORIES
#================================================================
# Simulation Area (which code to run): .
#       [barrow, arctic_coast, tanana, yukon, AIEM, ngee]
# Simulation_area: Barrow

#----------------------------------------------------------------
# Data Input, Output, and additional control file Directories
Input_dir: $input
Output_dir: $output
Control_dir: $control

"""
    )
    return s.substitute(
        input=settings['input-dir'], 
        output=settings['output-dir'],
        control=settings['control-dir']
    )
    
def add_runtime_settings (settings):
    """add settings used at runtime

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """

    s = Template(
"""
#================================================================
# INFORMATION NEEDED FOR RUNTIME CONFIGURATION
#================================================================

#----------------------------------------------------------------
#   Numba options:
#       Controls which version of the transition functions are 
#       used. 
#       "no": Uses standared transition functions (the string no)
#       "yes": use the Numba JIT enabled transition functions
#          (the string yes)
#       "cuda": use the Numba CUDA transition functions. Requires 
#           CUDA enabled graphics card, and CUDA drivers.
use_jit: "no" 

#----------------------------------------------------------------
#   Save runtime data options:
#       If a key is set to true the data created at runtime 
#       for each that grid is saved a serialized version of 
#       the object using multigrids serialization methods (The
#       objects are a saved a np.memmap's array buffer file, and
#       an associated yaml metadata file that can be read to 
#       access the data later). 
save_runtime_data:
    area: True
    ald: True
    climate_event: True
    drainage: True
    ice: True
    lake_pond: True
    poi: True

#----------------------------------------------------------------
#   Logging options:
#       log_each_time_step: (true, false)
#           log messages related to each model time step
#       Results_onscreen: (true, false)
#           print log messages too console?
#       save_log_to: (false, or a filename)
#           name of the file to write log to or false.
log_each_time_step: yes
Results_onscreen: Yes
save_log_to: no 

#----------------------------------------------------------------
#   Archive Options:
#       Archive_simulation:
#           Is the simulation archived (True, False).
#       Simulation_name: string
#           name associated with archive results.
Archive_simulation: Yes
Simulation_name: Historical_1901-2006

#----------------------------------------------------------------
#   Model testing options:
#       Test_code: (true, false)
#       Test_code_duration: int
#           number of timesteps to test code
#       skip_all_figures: (true, false)
#           Skip all figure generation
Test_code: No
Test_code_duration: 10
skip_all_figures: False

#----------------------------------------------------------------
#   Archive_data:
#       File Name Containing Archiving Information
Archive_data: 00_archive_data.yaml

#----------------------------------------------------------------
#   Initialize_Control:
#   Information needed to initialize the model
# rename initialization figures?
Initialize_Control: 00_Initialize_Control.yaml 
"""
    )
    return s.substitute()
    
def add_simulation_setup(settings):
    """add settings used for simulation setup

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    s = Template(
"""
#================================================================
# INFORMATION NEEDED TO RUN SIMULATION
#================================================================

# where does the model start at?
initialization year: 1900
start_year: 1901

#----------------------------------------------------------------
# Model resolution [meters]
# X_model_resolution: 1000.
# Y_model_resolution: 1000.

## target resloution [Y, X]
target resolution: [1000, 1000]

#----------------------------------------------------------------
#   Initial_Area_data:
#       File containing the list of rasters with init cohort area
#       data
Initial_Area_data: 00_Cohort_List.yaml

"""
    )
    return s.substitute()

def add_archive_header(settings):
    """add header for archive data

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    s =  "# Archive_data: \n"
    s += "#   If a ket is set to True the related resulted generated \n"
    s += "#   are saved in the archive. \n"
    return s


def add_archive_data(settings):
    """add archive data settings

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    s = Template(
"""Simulation_Summary: Yes
Initialization: Yes
Met: Yes
All_Cohorts: Yes
Lakes: Yes
Other_Cohorts: Yes
Ponds: Yes
Figures: Yes

"""
    )
    return s.substitute()

def add_initialize_control_header(settings):
    """returns initialize_control headder

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    return \
"""#================================================================
# Settings for which initial figures to save. 
#================================================================

"""
    
def add_initialize_control_body(settings):
    """returns initialize_control body 

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    s = add_break_line({'symbol':'-', 'len':64})
    s += "#  Initial cohort distribution figures\n"
    s += "Initial_Cohort_Distribution_Figure:  $ICDF\n"
    for cohort in settings['cohorts']:
        s += cohort +"_Figure: $ICDF\n"

    s += '\n' + add_break_line({'symbol':'-', 'len':64})
    s += "#  Normalized cohort distribution figures\n"
    s += "Normalized_Cohort_Distribution_Figure:  $NCDF\n"
    for cohort in settings['cohorts']:
        s += cohort +"_Normal: $NCDF\n"
    
    s += '\n' + add_break_line({'symbol':'-', 'len':64})
    s += "#  Initial cohort age figures\n"
    s += "Initial_Cohort_Age_Figure:  $ICAF\n"
    for cohort in settings['cohorts']:
        s += cohort +"_Age: $ICAF\n"

    return Template(s).substitute(
        ICDF=settings['init-dist-fig'],
        NCDF=settings['norm-dist-fig'],
        ICAF=settings['init-age-fig']
    )



def add_init_area_data_header(settings):
    """returns init_area_data headder

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    s  = "# Initial_Area_data: \n"
    s += "#   list of raster files contains initial areas for\n"
    s += "#   each cohort.\n"
    # initial area data: 00_Barrow_Initial_Cohort_List.yaml
    return s


def add_init_area_data_body(settings):
    """returns init_area_data body

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    s = ""
    for cohort in settings["cohorts"]:
        s += "- " + cohort + ".tif\n"

    return s


def substitute_archive_data(config_str, settings):
    """Substitute the archive data settins into main control string

    Parameters
    ----------
    config_str: string
    settings: dict

    Returns
    -------
    string
    """
    arch_data = '    ' + add_archive_data(settings).replace('\n', '\n    ')
    config_str = config_str.replace('00_archive_data.yaml', '\n'+arch_data)
    config_str = config_str.replace(
        '#   Initial_Area_data:\n'
        '#       File containing the list of rasters with init cohort area\n'
        '#       data\n', 
        add_archive_header(settings)
    )
    return config_str

def substitute_init_area_data(config_str, settings):
    """Substitute the archive data settins into main control string

    Parameters
    ----------
    config_str: string
    settings: dict

    Returns
    -------
    string
    """
    new_data = '    ' + add_init_area_data_body(settings).replace('\n', '\n    ')
    config_str = config_str.replace('00_Cohort_List.yaml', '\n'+new_data)
    config_str = config_str.replace(
        '#   Archive_data:'+\
            '\n#       File Name Containing Archiving Information\n'
        , add_init_area_data_header(settings)
    )
    return config_str

def generate_initialize(settings):
    """Generate the initialize settings string

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    s = add_initialize_control_header(settings)
    s += add_yaml_notes(settings)
    s += add_initialize_control_body(settings)
    return s

def generate_archive_data(settings):
    """Generate the archive data settings string

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    config_str = add_break_line({'symbol':'=', 'len':64})
    config_str += add_archive_header(settings)
    config_str += add_break_line({'symbol':'=', 'len':64})
    config_str += '\n'
    config_str += add_yaml_notes(settings)
    config_str += add_archive_data(settings)

    return config_str

def generate_lake_pond (settings):
    """Generate the lake/pond settings string

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    s = add_break_line({'symbol':'=', 'len':64})
    s += "# Lake Pond Control settings\n"
    s += add_break_line({'symbol':'=', 'len':64})
    s += '\n'
    s += add_yaml_notes(settings)
    s += add_break_line({'symbol':'-', 'len':64})
    s += '#   Lake_Distribution:\n'
    s += '#     Distribution of Lake depth (uniform, random)\n'
    s += '#   Uniform_Lake_Depth: number\n'
    s += '#     Depth of lakes if Lake_Distribution is uniform\n'
    s += '#   Lower_Lake_Depth: \n'
    s += '#   Upper_Lake_Depth: \n'
    s += '#     Boundaries for random distribution\n'
    s += 'Lake_Distribution: Random\n'
    s += 'Uniform_Lake_Depth: 3.5\n'
    s += 'Lower_Lake_Depth: 2.2\n'
    s += 'Upper_Lake_Depth: 5.0\n\n'

    s += add_break_line({'symbol':'-', 'len':64})
    s += '#   Pond_Distribution:\n'
    s += '#     Distribution of Pond depth (uniform, random)\n'
    s += '#   Uniform_Pond_Depth: number\n'
    s += '#     Depth of Ponds if Pond_Distribution is uniform\n'
    s += '#   Lower_Pond_Depth: \n'
    s += '#   Upper_Pond_Depth: \n'
    s += '#     Boundaries for random distribution\n'
    s += 'Pond_Distribution: Random\n'
    s += 'Uniform_Pond_Depth: 1.5\n'
    s += 'Lower_Pond_Depth: 1.25\n'
    s += 'Upper_Pond_Depth: 1.7\n\n'

    s += add_break_line({'symbol':'-', 'len':64})
    s += "#   *_Expansion: number\n"
    s += "#     rate of expansion for a lake or pond cohort type\n"
    for t in settings['lake_types'] + settings['pond_types']:
        s += t + '_Expansion: 0.0001\n' 
    s += '\n'
    
    s += add_break_line({'symbol':'-', 'len':64})
    s += "#   Ponds_fill_to: string\n"
    s += "#     name of cohoort ponds transition to as infill occurs"
    s += "#   *_Infill_Constant: number\n"
    s += "#     Constant for each pond type used to calculate infill.\n"
    s += "#   *_growth_time_required: number (int >1)]\n"
    s += "#     Number of consecutive years a pond must grow (in depth)\n"
    s += "#     before it is allowed to transition to a lake\n"
    s += "Ponds_fill_to: $pft \n"
    for t in settings['pond_types']:
        s += t + '_Infill_Constant: 0.005\n' 
    for t in settings['pond_types']:
        s += t + '_growth_time_required: 1\n' 
    s += '\n'

    s += add_break_line({'symbol':'-', 'len':64})
    s += '#   ice_thickness_distribution:\n'
    s += '#     Distribution of Lake depth (uniform, random)\n'
    s += '#   ice_thickness_uniform_alpha: number\n'
    s += '#     Depth of lakes if Lake_Distribution is uniform\n'
    s += '#   Lower_ice_thickness_alpha: \n'
    s += '#   Upper_ice_thickness_alpha: \n'
    s += '#     Boundaries for random distribution\n'
    s += 'ice_thickness_distribution: Random\n'
    s += 'ice_thickness_uniform_alpha: 2.4: 3.5\n'
    s += 'Lower_ice_thickness_alpha: 2.2\n'
    s += 'Upper_ice_thickness_alpha: 5.0\n\n'

    s += add_break_line({'symbol':'-', 'len':64})
    s += "#   *_depth_control: number\n"
    s += "#     constants used in calculateing change in lake/pond depth\n"
    s += "#     Approximate Square Root of Time Function\n"
    s += "#     Depth_Change = sqrt(time)/[pond/lake]_depth_control\n"
    for t in settings['lake_types']:
        s += t + '_depth_control: 100\n' 
    for t in settings['pond_types']:
        s += t + '_depth_control: 10\n' 
    s += '\n'

    s += add_break_line({'symbol':'-', 'len':64})
    s += "#   Output Control for Lake & Pond Depth\n"
    s += "figures:\n"
    for t in settings['lake_types'] + settings['pond_types']:
        s += '    ' + t + '_Depth_Figure: Yes\n' 

    return Template(s).substitute(pft=settings['ponds-fill-to'])


def generate_terrestrial(settings):
    """Generate the terrestrial settings string

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    s = add_break_line({'symbol':'=', 'len':64})
    s += "# Terrestrial Control settings\n"
    s += add_break_line({'symbol':'=', 'len':64})
    s += '\n'
    s += add_yaml_notes(settings)
    s += add_break_line({'symbol':'-', 'len':64})
    s += "#   Ice Distribution settings\n"
    s += "#     Ice_Distribution: String\n"
    s += "#         'poor', 'pore', 'wedge', or 'massive'\n"
    s += "#     Ice_Distribution_Figure: bool\n"
    s += "Ice_Distribution: $icedist \n"
    s += "Ice_Distribution_Figure: Yes \n\n"
    s += add_break_line({'symbol':'-', 'len':64})
    s += "#   Drainage Efficiency Settings\n"
    s += "#     Drainage_Efficiency_Distribution: String\n" 
    s += "#         'above', 'below', or 'random' \n" 
    s += "#     Drainage_Efficiency_Random_Value: number (0, 1]\n" 
    s += "#         Threshold used to determine if random drainage is\n" 
    s += "#         'above' or 'below'\n" 
    s += "#     Drainage_Efficiency_Figure: bool\n" 
    s += "Drainage_Efficiency_Distribution: $draineff \n" 
    s += "Drainage_Efficiency_Random_Value: 0.85 \n" 
    s += "Drainage_Efficiency_Figure: Yes \n\n" 
    
    s += add_break_line({'symbol':'-', 'len':64})
    s += "#   ALD settings\n"
    s += "#     ALD_Distribution: string\n"
    s += "#         method of ALD initialization\n"
    s += "#         model framework currently only supports 'random'\n"
    s += "#     Initial_ALD_range: [lower(m), upper(m)]\n"
    s += "#         lower and upper range for random ald \n"
    s += "#         initialization in meters\n"
    s += "#     ALD_Distribution_Output: bool\n"
    s += "#     ALD_Factor_Output: bool\n"
    # s += "#     Protective_Layer_Factor_Output: bool\n"
    s += "#         Control figure generation\n"
    s += "#     *_PLF: number\n"
    s += "#         Set the protective layer factor for each cohort\n"
    s += "# Note: The initial protective layer is calculated\n"
    s += "# as the (Initial Active Layer * Protective Layer Factor)\n"
    s += "ALD_Distribution: random\n" 
    s += "Initial_ALD_range: [.3, .75]\n" 
    s += "ALD_Distribution_Output: Yes\n" 
    s += "ALD_Factor_Output: No\n" 
    # s += "Protective_Layer_Factor_Output: No\n"
    for cohort in settings['cohorts']:
        s += cohort + "_PLF: 1.0\n"
    s += '\n'
    s += add_break_line({'symbol':'-', 'len':64})
    s += "#   Dominate Cohort figure/video options\n"
    s += "#     Figure: bool\n"
    s += "#     Movie: bool\n"
    s += "Figure: Yes\n"
    s += "Movie: Yes\n"   
    return Template(s).substitute(
        icedist=settings['ice-distribution'],
        draineff=settings['drainage-efficiency']
    )

def generate_met(settings):
    """Generate the met settings string

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    s = add_break_line({'symbol':'=', 'len':64})
    s += "# Meteorologic data Control settings\n"
    s += add_break_line({'symbol':'=', 'len':64})
    s += '\n'
    s += add_yaml_notes(settings)
    s += add_break_line({'symbol':'-', 'len':64})   
    s += "#   met_distribution: string\n"
    s += "#     Meteorologic data distribution.\n"
    s += "#     Currently framework supports 'spatial'.\n"
    ######### start of not implemented features from bobs original code
    # s += "#     The other possible option is 'point'.\n"  
    # s += "#   met_file_point: string\n"
    # s += "#   met_file_distributed: string\n"
    # s += "#       Names of files that contain meterological data 
    # s += "#       information -- excel (xls) file for point data, 
    # s += "#       geotif for spatial data. 
    ######### end 
    s += "#   degree_day_method: string\n"
    s += "#     Method of degreeday input. Currently framework supports 'read'\n"
    s += "#     method where the thawing degree day, \n"
    s += "#     freezing degree day have been pre calculated.\n"
    s += "#   TDD_file: string\n"
    s += "#   FDD_file: string\n"
    s += "#     Names of pre-calculated degreeday data files.\n"
    s += "#     (Currenlty saved with multigrids where\n"
    s += "#     objects are a saved a np.memmap's array buffer file, and\n"
    s += "#     an associated yaml metadata file that can be read to\n" 
    s += "#     reconstruct data later). \n"
    s += "#   Degree_Day_Output: bool\n"
    s += "#   TDD_Output: string\n"
    s += "#   FDD_Output: string\n"
    s += "#     settings on if and where to save calculated degree day files,\n"
    s += "#     and/or figure files for degree day data. The _output fields\n"
    s += "#     indicate subdirectories in the main model output directory.\n"
    # s += "met_distribution: spatial\n"
    # s += "met_file_point: BarrowMET_2006_2100.xls\n"
    # s += "met_file_distributed: Barrow_AT_1901-2009_V1\n"
    s += "degree_day_method: read\n"
    s += "TDD_file: $TDDfile \n"
    s += "FDD_file: $FDDfile \n"
    s += "Degree_Day_Output: Yes\n"
    s += "TDD_Output: TDD_output\n"
    s += "FDD_Output: FDD_output\n\n"
    
    s += add_break_line({'symbol':'-', 'len':64}) 
    s += "# Climate event settings.\n"
    s += "#   climate_blocks: 'random' or number (int)\n"
    s += "#     size of climate event blocks in number grid cells\n"
    s += "#   climate_block_lower_bound: number (int)\n"
    s += "#   climate_block_upper_bound: number (int)\n"
    s += "#     bounds of random climate block size\n"
    s += "#   climate_event_probability: number [0,1]\n"
    s += "#     probability of a climate event occurring in climate block.\n"
    s += "#   lakes_drain_to: string\n"
    s += "#     name of cohort that lakes/ponds drained by climate events\n"
    s += "#     become.\n"
    s += "#   pond_drain_rate_<0.01: number [0,1]\n"
    s += "#   pond_drain_rate_0.01<0.1: number [0,1]\n"
    s += "#   pond_drain_rate_0.1<0.4: number [0,1]\n"
    s += "#   pond_drain_rate_0.4<1.0: number [0,1]\n"
    s += "#   lake_drain_rate_<0.01: number [0,1]\n"
    s += "#   lake_drain_rate_0.01<0.1: number [0,1]\n"
    s += "#   lake_drain_rate_0.1<0.4: number [0,1]\n"
    s += "#   lake_drain_rate_0.4<1.0: number [0,1]\n"
    s += "#     Rates of drainage caused by climate events. The ranges at the\n"
    s += "#     end of each setting indicate the range of fractional area\n"
    s += "#     values that each rate apply to.\n"
    s += "climate_blocks: random\n"
    s += "climate_block_lower_bound: 5\n"
    s += "climate_block_upper_bound: 25\n"
    s += "climate_event_probability: 0.005\n"
    s += "lakes_drain_to: $lakesdrainto \n"
    s += "pond_drain_rate_<0.01: 0.0005\n"
    s += "pond_drain_rate_0.01<0.1: 0.0005\n"
    s += "pond_drain_rate_0.1<0.4: 0.0005\n"
    s += "pond_drain_rate_0.4<1.0: 0.0005\n"
    s += "lake_drain_rate_<0.01: 0.0005\n"
    s += "lake_drain_rate_0.01<0.1: 0.0010\n"
    s += "lake_drain_rate_0.1<0.4: 0.0017\n"
    s += "lake_drain_rate_0.4<1.0: 0.0025\n"

    return Template(s).substitute(
        TDDfile=settings['TDD-in'],
        FDDfile=settings['FDD-in'],
        lakesdrainto=settings['lakes-drain-to']
    )


def generate_init_area_data(settings):
    """Generate the init_area_data string

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    config_str = add_break_line({'symbol':'=', 'len':64})
    config_str += add_init_area_data_header(settings)
    config_str += add_break_line({'symbol':'=', 'len':64})
    config_str += '\n'
    config_str += add_yaml_notes(settings)
    config_str += add_init_area_data_body(settings)
    return config_str


def generate_main (settings=example):
    """Generate the main settings string

    Parameters
    ----------
    settings: dict

    Returns
    -------
    string
    """
    config_str = ""
    config_str += add_main_header(settings)
    config_str += add_yaml_notes(settings)
    config_str += add_directory_info(settings)
    config_str += add_runtime_settings(settings)
    config_str += add_simulation_setup(settings)
    return config_str

def get_poi_based_transition (settings):
    """get the POI transition string

    Parameters
    ----------
    settings: dict

    Returns
    -------
    Template()
    """
    s = \
"""#----------------------------------------------------------
# Form of Probability of Initiation (Sigmoid, Sigmoid2, linear,
#   Hill)
#----------------------------------------------------------
Transition_check_type: POI
POI_Function: Sigmoid2
transitions_to: $TT
# ============================================================
# The Sigmoid Function
# POI = A2 + (A1 - A2) / (1. + exp((x - x0) / dx))
#---------------------------------------------------------
#============================================================
# The Sigmoid2 Function
# POI = K / (C + (A*x**B))
#------------------------------------------------------------
#============================================================
# The linear function
# POI = a + (b * x )
#----------------------------------------------------------
#===========================================================
# The Hill Function
# POI = (B*(x^n))/(1+(x^n))
#----------------------------------------------------------
Parameters:
    # Parameter values for cohorts above the drainage threshold
    above:
        sigmoid_A1: -1.186e-1
        sigmoid_A2: 1.01
        sigmoid_x0: 4.856e-1
        sigmoid_dx: 1.398e-1
        
        sigmoid2_K: 10.
        sigmoid2_C: 10.
        sigmoid2_A: 0.5
        sigmoid2_B: -2.0

        linear_a: 0.0
        linear_b: 0.4

        hill_B: 1.0
        hill_N: 0.5

    # Parameter values for cohorts below the drainage threshold
    below:
        sigmoid_A1: 3.454e-2
        sigmoid_A2: 1.01
        sigmoid_x0: 1.04
        sigmoid_dx: 1.617e-1

        sigmoid2_K: 10.
        sigmoid2_C: 10.
        sigmoid2_A: 3.0
        sigmoid2_B: -3.0


        linear_a: 0.0
        linear_b: 0.2

        hill_B: 1.0
        hill_N: 0.5
#===========================================================
# Maximum rate of terrain transition
#-----------------------------------------------------------
max_terrain_transition: 0.25
#===========================================================
# Rate transitions as a function of ice content
#-----------------------------------------------------------
ice_slope_poor: 0.05
ice_slope_pore: 0.5
ice_slope_wedge: 0.5
ice_slope_massive: 1.0
#===========================================================
# Soil Properties
# Note: Porosity must be between 0 - 1.0
#-----------------------------------------------------------
porosity: 0.5
#===========================================================
# Output results
# ----------------------------------------------------------
# Note: In order for an animation to be output, Figures 
# must be set to 'Yes' (results in *.bin and *.jpg
# files)
#-----------------------------------------------------------
Figures: No
Movie: No
#-----------------------------------------------------------
"""
    return Template(s)

def get_lake_to_pond_transition(settings):
    """get the lake_to_pond transition string

    Parameters
    ----------
    settings: dict

    Returns
    -------
    Template()
    """
    s = \
"""#----------------------------------------------------------
# Control file template for lake/ponds, most config comes f
# from lake_pond_control 
#----------------------------------------------------------
Transition_check_type: lake_to_pond
transitions_to: $TT

## Figures
Figures: Yes
Movie: No

"""
    return Template(s)


def get_pond_to_lake_transition(settings):
    """get the pond_to_lake transition string

    Parameters
    ----------
    settings: dict

    Returns
    -------
    Template()
    """
    s = \
"""#----------------------------------------------------------
# Control file template for lake/ponds, most config comes f
# from lake_pond_control 
#----------------------------------------------------------
Transition_check_type: pond_to_lake
transitions_to: $TT

## Figures
Figures: Yes
Movie: Yes
"""
    return Template(s)


def generate_cohort_congifs(settings):
    """Generate the settings strings for each cohort config

    Parameters
    ----------
    settings: dict

    Returns
    -------
    dict
        dictionary of settings strings generated
    """
    cfgs = {}
    t_table = {
        "POI": get_poi_based_transition,
        "lake_to_pond": get_lake_to_pond_transition,
        "pond_to_lake": get_pond_to_lake_transition
    }

    for cohort in settings['cohort-transitions']:
        cohort_settings = settings['cohort-transitions'][cohort]
        t_type = cohort_settings['transition_type']
        t_to = cohort_settings['transition_to']

        cfgs[cohort+'_config'] = t_table[t_type](settings).substitute(TT=t_to)
    return cfgs

def generate(settings=example):
    """Generate the settings strings

    Parameters
    ----------
    settings: dict

    Returns
    -------
    dict
        dictionary of settings strings generated
    """
    configs = {}
    configs['main'] = generate_main(settings)
    
    if settings['seprate_archive_data']:
        configs['archive_data'] = generate_archive_data(settings)
    else:
        configs['main'] = substitute_archive_data(configs['main'], settings)

    if settings['seprate_init_area_data']:
        configs['init_area_data'] = generate_init_area_data(settings)
    else:
        configs['main'] = substitute_init_area_data(configs['main'], settings)

    configs['initialize'] = generate_initialize(settings)

    configs['met'] = generate_met(settings)
    configs['terrestrial'] = generate_terrestrial(settings)
    
    configs['lake_pond'] = generate_lake_pond(settings)

    configs.update(generate_cohort_congifs(settings))
    return configs



